<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bolero Book</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="expanded "><a href="cli-installation.html"><strong aria-hidden="true">1.1.</strong> CLI Installation</a></li><li class="expanded "><a href="library-installation.html"><strong aria-hidden="true">1.2.</strong> Library Installation</a></li></ol></li><li class="expanded "><a href="features/index.html"><strong aria-hidden="true">2.</strong> Features</a></li><li><ol class="section"><li class="expanded "><a href="features/corpus-replay.html"><strong aria-hidden="true">2.1.</strong> Corpus Replay</a></li><li class="expanded "><a href="features/input-shrinking.html"><strong aria-hidden="true">2.2.</strong> Input Shrinking</a></li><li class="expanded "><a href="features/rust-stable.html"><strong aria-hidden="true">2.3.</strong> Works on Rust Stable</a></li><li class="expanded "><a href="features/structured-testing.html"><strong aria-hidden="true">2.4.</strong> Structured Testing</a></li><li class="expanded "><a href="features/unified-interface.html"><strong aria-hidden="true">2.5.</strong> Unified Interface</a></li><li class="expanded "><a href="features/private-testing.html"><strong aria-hidden="true">2.6.</strong> Private Testing</a></li><li class="expanded "><a href="features/miri.html"><strong aria-hidden="true">2.7.</strong> Miri Support</a></li></ol></li><li class="expanded "><a href="tutorials/index.html"><strong aria-hidden="true">3.</strong> Tutorials</a></li><li><ol class="section"><li class="expanded "><a href="tutorials/fibonacci.html"><strong aria-hidden="true">3.1.</strong> Fibonacci</a></li></ol></li><li class="expanded "><a href="dev-docs/index.html"><strong aria-hidden="true">4.</strong> Developer documentation</a></li><li><ol class="section"><li class="expanded "><a href="dev-docs/build.html"><strong aria-hidden="true">4.1.</strong> Build from source</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Bolero Book</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Bolero is a fuzzing and property testing front-end framework for Rust.</p>
<p>From <a href="https://en.wikipedia.org/wiki/Fuzzing">Wikipedia</a>, fuzzing is described as:</p>
<blockquote>
<p>Fuzzing or fuzz testing is an automated software testing technique that involves providing invalid, unexpected, or random data as inputs to a computer program. The program is then monitored for exceptions such as crashes, failing built-in code assertions, or potential memory leaks.</p>
</blockquote>
<p><code>bolero</code>'s goal is to make implementing high-quality tests as painless and approachable as possible.</p>
<h1><a class="header" href="#cli-installation" id="cli-installation">CLI Installation</a></h1>
<p><code>bolero</code> provides a CLI program to execute tests, <a href="https://crates.io/crates/cargo-bolero"><code>cargo-bolero</code></a>. It can be installed globally with cargo:</p>
<pre><code class="language-bash">$ cargo install cargo-bolero -f
</code></pre>
<h2><a class="header" href="#linux-installation" id="linux-installation">Linux Installation</a></h2>
<p><code>cargo-bolero</code> needs a couple of libraries installed to compile. If these libraries aren't
available the requirement can be relaxed by executing <code>cargo install cargo-bolero --no-default-features -f</code></p>
<h3><a class="header" href="#debianubuntu" id="debianubuntu">Debian/Ubuntu</a></h3>
<pre><code class="language-bash">$ sudo apt install binutils-dev libunwind-dev
</code></pre>
<h3><a class="header" href="#nix" id="nix">Nix</a></h3>
<pre><code class="language-bash">$ nix-shell -p libbfd libunwind libopcodes
</code></pre>
<h1><a class="header" href="#library-installation" id="library-installation">Library Installation</a></h1>
<p><code>bolero</code> is on <code>crates.io</code> and can be added to a project's dev dependencies like so:</p>
<pre><code class="language-shell">$ cargo add --dev bolero
</code></pre>
<p>Or add</p>
<pre><code class="language-toml">[dev-dependencies]
bolero = &quot;0.9&quot;
</code></pre>
<p>to <code>Cargo.toml</code>.</p>
<p>Then, create the <code>fuzz</code> profile: (Note that LTO is not well-supported for the fuzzing profile)</p>
<pre><code class="language-toml">[profile.fuzz]
inherits = &quot;dev&quot;
opt-level = 3
incremental = false
codegen-units = 1
</code></pre>
<p>If you forget adding the profile, then you will get the following error:</p>
<pre><code>error: profile `fuzz` is not defined
</code></pre>
<h2><a class="header" href="#structured-test-generation" id="structured-test-generation">Structured Test Generation</a></h2>
<p>If your crate wishes to implement structured test generation on public data structures, <code>bolero-generator</code> can be added to the main dependencies:</p>
<pre><code class="language-shell">$ cargo add bolero-generator
</code></pre>
<pre><code class="language-toml">[dependencies]
bolero-generator = &quot;0.9&quot;
</code></pre>
<p>The derive attribute can now be used:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, bolero_generator::TypeGenerator)]
pub struct Coord3d {
    x: u64,
    y: u64,
    z: u64,
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#features" id="features">Features</a></h1>
<p>Bolero has several features that make testing easy:</p>
<ul>
<li><a href="features/./corpus-replay.html">Corpus Replay</a></li>
<li><a href="features/./input-shrinking.html">Input Shrinking</a></li>
<li><a href="features/./rust-stable.html">Works on Rust Stable</a></li>
<li><a href="features/./structured-testing.html">Structured Testing</a></li>
<li><a href="features/./unified-interface.html">Unified Interface</a></li>
<li><a href="features/./private-testing.html">Private Testing</a></li>
<li><a href="features/./miri.html">Miri Support</a></li>
</ul>
<h1><a class="header" href="#corpus-replay" id="corpus-replay">Corpus Replay</a></h1>
<p>After executing  a test target, a corpus is generated. A corpus is a set of inputs that trigger unique codepaths. This corpus can be now executed using the standard <code>cargo test</code> command. The corpus should either be commited to the project repository or be stored/restored from storage, like S3.</p>
<pre><code class="language-bash">$ cargo test

     Running target/debug/deps/my_test_target-9b2c2acee51634e0

running 1007 tests
...............................................................................
...............................................................................
...............................................................................
...............................................................................
...............................................................................
...............................................................................
...............................................................................
...............................................................................
...............................................................................
...............................................................................
...............................................................................
...............................................................................
...........................................................
test result: ok. 1007 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h1><a class="header" href="#input-shrinking" id="input-shrinking">Input Shrinking</a></h1>
<p><code>bolero</code> supports input shrinking for all of the provided testing engines.</p>
<h2><a class="header" href="#what-is-it" id="what-is-it">What is it?</a></h2>
<p>From <a href="https://propertesting.com/book_shrinking.html">PropEr Testing</a>:</p>
<blockquote>
<p>Shrinking is the mechanism by which a property-based testing framework can be told how to simplify failure cases enough to let it figure out exactly what the minimal reproducible case is.</p>
<p>Sometimes the input required to find a failure can be fairly large or complex. Finding the initial failing case may have required hundreds of attempts, and it may contain vast amounts of irrelevant information. The framework will then attempt to reduce that data set through shrinking. It generally does so by transforming all the generators used and trying to bring them back towards their own zero point.</p>
</blockquote>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<p>Let's suppose we're testing a <code>MySet</code> data structure:</p>
<pre><pre class="playpen"><code class="language-rust">use bolero::{check, generator::*};
use my_set::MySet;

#[derive(Debug, TypeGenerator)]
enum Operation {
    Insert(u64),
    Remove(u64),
    Clear,
}

fn main() {
    check!()
        .with_type::&lt;Vec&lt;Operation&gt;&gt;()
        .for_each(|operations| {
            let mut set = MySet::new();

            for operation in operations.iter() {
                match operation {
                    Operation::Insert(value) =&gt; {
                        set.insert(value);
                    }
                    Operation::Remove(value) =&gt; {
                        set.remove(value);
                    }
                    Operation::Clear =&gt; {
                        set.clear();
                    }
                }
            }
        })
}
</code></pre></pre>
<p>Assume there's hypothetical scenario in which adding 16 elements to <code>MySet</code> causes a panic. Without shrinking, the randomly-generated inputs can be difficult to interpret:</p>
<pre><code>======================== Test Failure ========================

Input:
[
    Insert(9693583160302274182),
    Insert(15890536247564076678),
    Clear,
    Insert(15914819332679195868),
    Insert(9717884937115065564),
    Insert(15914645609842007260),
    Insert(18446738425238052060),
    Remove(15912577393975689024),
    Insert(15338377272073444572),
    Insert(15914838024242123988),
    Insert(11228695243045262548),
    Insert(11212726789901900955),
    Insert(11212726789901884315),
    Insert(11212726789901884316),
    Insert(11212726789901884317),
    Insert(11212726789901884318),
    Insert(11212726789901884319),
    Insert(11212726789901884311),
    Insert(11212726789901884312),
    Insert(11212726789901884313),
    Insert(11212726789901884314),
    Insert(9727500806739001343),
    Insert(9693583160302274182),
    Insert(9693583160302274182),
    Insert(5714873654208093419),
    Remove(5714873654208057167),
    Remove(16717362667219255119),
    Insert(9726366166670698728),
    Insert(9727642152175306374),
    Remove(18446181099529437184),
    Insert(18446744073709551615),
    Insert(15336116641675083775),
    Remove(11212726789901884372),
    Insert(11212726789901884315),
    Insert(11212666079612935067)
]

Error:
panicked at 'internal assertion', src/lib.rs:16:17
</code></pre>
<p>After shrinking the input, it becomes more obvious how to trigger the bug:</p>
<pre><code>======================== Test Failure ========================

Input:
[
    Insert(0),
    Insert(1),
    Insert(2),
    Insert(3),
    Insert(4),
    Insert(5),
    Insert(6),
    Insert(7),
    Insert(8),
    Insert(9),
    Insert(10),
    Insert(11),
    Insert(12),
    Insert(13),
    Insert(14),
    Insert(15),
]

Error:
panicked at 'internal assertion', src/lib.rs:16:17
</code></pre>
<h1><a class="header" href="#works-on-rust-stable" id="works-on-rust-stable">Works on Rust Stable</a></h1>
<p><code>bolero</code> does not require nightly to execute test targets:</p>
<pre><code class="language-bash"># does not require nightly
$ cargo bolero test my_test_target --sanitizer NONE
</code></pre>
<h2><a class="header" href="#sanitizer-support" id="sanitizer-support">Sanitizer support</a></h2>
<p>Using a sanitizer will improve the number of edge cases caught by the test. As such, the preference should be towards using them. Unfortunately, sanitizers require Rust nightly to compile.</p>
<p><code>cargo-bolero</code> will use <code>cargo +nightly</code> instead to execute the test target:</p>
<pre><code class="language-bash"># uses nightly, even if we're using stable by default
$ cargo bolero test --sanitizer address my_test_target
</code></pre>
<p>If a specific version of nightly is required, the <code>--toolchain</code> argument can be used:</p>
<pre><code class="language-bash">$ cargo bolero test --sanitizer address --toolchain nightly-2020-01-01 my_test_target
</code></pre>
<h1><a class="header" href="#structured-testing" id="structured-testing">Structured Testing</a></h1>
<p>In addition to generating random byte slices, <code>bolero</code> supports generating well-formed types, with the <a href="https://docs.rs/bolero-generator/"><code>bolero-generator</code></a> crate.</p>
<h2><a class="header" href="#operation-example" id="operation-example">Operation Example</a></h2>
<p>Let's supposes we've implemented a <code>MySet</code> data structure. It has 3 operations:</p>
<ul>
<li><code>insert(value)</code> - inserts an value into the set</li>
<li><code>remove(value)</code> - removes an value from the set</li>
<li><code>clear()</code> - removes all values from the set</li>
</ul>
<p>The operations can easily be modeled as an <code>enum</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use bolero::generator::TypeGenerator;

#[derive(Debug, TypeGenerator)]
enum Operation {
    Insert(u64),
    Remove(u64),
    Clear,
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that we've added <code>TypeGenerator</code> to the list of derives. This enables <code>bolero</code> to generate random values for <code>Operation</code>. We can combine that with a <code>Vec&lt;Operation&gt;</code> and get a list of operations to perform on our <code>MySet</code> data structure.</p>
<pre><pre class="playpen"><code class="language-rust">use bolero::{check, generator::*};
use my_set::MySet;

#[derive(Debug, TypeGenerator)]
enum Operation {
    Insert(u64),
    Remove(u64),
    Clear,
}

fn main() {
    check!()
        .with_type::&lt;Vec&lt;Operation&gt;&gt;()
        .for_each(|operations| {
            let mut set = MySet::new();

            for operation in operations.iter() {
                match operation {
                    Operation::Insert(value) =&gt; {
                        set.insert(value);
                    }
                    Operation::Remove(value) =&gt; {
                        set.remove(value);
                    }
                    Operation::Clear =&gt; {
                        set.clear();
                    }
                }
            }
        })
}
</code></pre></pre>
<p>This basic test will make sure we don't panic on any of the list of operations. We can take it to the next step by using a test oracle to make sure the behavior of <code>MySet</code> is actually correct. Here we'll use <code>HashSet</code> from the <code>std</code> library:</p>
<pre><pre class="playpen"><code class="language-rust">use bolero::{check, generator::*};
use my_set::MySet;
use std::collections::HashSet;

#[derive(Debug, TypeGenerator)]
enum Operation {
    Insert(u64),
    Remove(u64),
    Clear,
}

fn main() {
    check!()
        .with_type::&lt;Vec&lt;Operation&gt;&gt;()
        .for_each(|operations| {
            let mut set = MySet::new();
            let mut oracle = HashSet::new();

            for operation in operations.iter() {
                match operation {
                    Operation::Insert(value) =&gt; {
                        set.insert(value);
                        oracle.insert(value);
                    }
                    Operation::Remove(value) =&gt; {
                        set.remove(value);
                        oracle.remove(value);
                    }
                    Operation::Clear =&gt; {
                        set.clear();
                        oracle.clear();
                    }
                }
            }

            assert!(set.iter().eq(oracle.iter()));
        })
}
</code></pre></pre>
<h1><a class="header" href="#unified-interface" id="unified-interface">Unified Interface</a></h1>
<p>Using the interface provided by <code>bolero</code>, a single test target can execute under several different engines.</p>
<h2><a class="header" href="#libfuzzer" id="libfuzzer">LibFuzzer</a></h2>
<ul>
<li><a href="https://llvm.org/docs/LibFuzzer.html">LibFuzzer documentation</a></li>
</ul>
<p>LibFuzzer is an in-process, coverage-guided, evolutionary fuzzing engine.</p>
<p>LibFuzzer is linked with the library under test, and feeds fuzzed inputs to the library via a specific fuzzing entrypoint (aka “target function”); the fuzzer then tracks which areas of the code are reached, and generates mutations on the corpus of input data in order to maximize the code coverage.</p>
<p>The <code>libfuzzer</code> engine can be selected like so:</p>
<pre><code class="language-bash">$ cargo bolero test --engine libfuzzer my_test_target
</code></pre>
<p>Currently, it is also the default engine:</p>
<pre><code class="language-bash"># will use --engine libfuzzer
$ cargo bolero test my_test_target
</code></pre>
<h2><a class="header" href="#afl" id="afl">AFL</a></h2>
<ul>
<li><a href="http://lcamtuf.coredump.cx/afl/">AFL documentation</a></li>
</ul>
<p>American fuzzy lop is a security-oriented fuzzer that employs a novel type of compile-time instrumentation and genetic algorithms to automatically discover clean, interesting test cases that trigger new internal states in the targeted binary. This substantially improves the functional coverage for the fuzzed code. The compact synthesized corpora produced by the tool are also useful for seeding other, more labor- or resource-intensive testing regimes down the road.</p>
<p>The <code>afl</code> engine can be selected like so:</p>
<pre><code class="language-bash">$ cargo bolero test --engine afl my_test_target
</code></pre>
<h2><a class="header" href="#honggfuzz" id="honggfuzz">Honggfuzz</a></h2>
<ul>
<li><a href="https://google.github.io/honggfuzz/">Honggfuzz documentation</a></li>
</ul>
<p>Honggfuzz is a security oriented fuzzer with powerful analysis options. Supports evolutionary, feedback-driven fuzzing based on code coverage (software- and hardware-based)</p>
<p>The <code>honggfuzz</code> engine can be selected like so:</p>
<pre><code class="language-bash">$ cargo bolero test --engine honggfuzz my_test_target
</code></pre>
<h2><a class="header" href="#kani" id="kani">Kani</a></h2>
<ul>
<li><a href="https://model-checking.github.io/kani/">Kani documentation</a></li>
</ul>
<p>Kani is an open-source verification tool that uses automated reasoning to analyze Rust programs. Kani is particularly useful for verifying unsafe code in Rust, where many of the Rust’s usual guarantees are no longer checked by the compiler. Some example properties you can prove with Kani include memory safety properties (e.g., null pointer dereferences, use-after-free, etc.), the absence of certain runtime errors (i.e., index out of bounds, panics), and the absence of some types of unexpected behavior (e.g., arithmetic overflows). Kani can also prove custom properties provided in the form of user-specified assertions.</p>
<p>Kani uses proof harnesses to analyze programs. Proof harnesses are similar to test harnesses, especially property-based test harnesses.</p>
<p>The <code>kani</code> engine can be selected like so:</p>
<pre><code class="language-bash">$ cargo bolero test --engine kani my_test_target
</code></pre>
<p>Note that each target needs to include a <code>#[kani::proof]</code> attribute:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[test]
#[cfg_attr(kani, kani::proof)]
fn my_test_target() {
    bolero::check!().with_type().for_each(|v: &amp;u8| {
        assert_ne!(*v, 123);
    });
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#private-testing" id="private-testing">Private Testing</a></h1>
<p><code>bolero</code> also supports running tests inside of a project. This is useful for testing private interfaces and implementations.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[test]
fn my_property_test() {
    bolero::check!()
        .with_type()
        .cloned()
        .for_each(|value: u64| {
            // implement property checks here
        });
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#miri-support" id="miri-support">Miri Support</a></h1>
<p><code>bolero</code> supports executing tests with <a href="https://github.com/rust-lang/miri">Miri</a>. Keep in mind that execution is significantly slower in Miri.</p>
<p>The isolation mode must currently be disabled in order for bolero tests to read corpuses from the file system. This can be done by setting the appropriate flags:</p>
<pre><code class="language-bash">MIRIFLAGS=&quot;-Zmiri-disable-isolation&quot; cargo +nightly miri test
</code></pre>
<h1><a class="header" href="#tutorials" id="tutorials">Tutorials</a></h1>
<ul>
<li><a href="tutorials/./fibonacci.html">Fibonacci</a></li>
</ul>
<h1><a class="header" href="#fibonacci" id="fibonacci">Fibonacci</a></h1>
<p>In this tutorial, we want to arrive at a bug-free fibonacci implementation. Let's start with a basic setup:</p>
<pre><code class="language-bash">$ cargo new --lib my_fibonacci
</code></pre>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// src/lib.rs

pub fn fibonacci(number: u64) -&gt; u64 {
    let mut a = 0;
    let mut b = 1;

    for _ in 0..number {
        b += core::mem::replace(&amp;mut a, b);
    }

    b
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we define a test:</p>
<pre><code class="language-bash">$ cargo bolero new fibonacci_test --generator
</code></pre>
<pre><pre class="playpen"><code class="language-rust">// tests/fibonacci_test/main.rs
use bolero::check;
use my_fibonacci::fibonacci;

fn main() {
    check!()
        .with_type()
        .cloned()
        .for_each(|number: u64| {
            fibonacci(number);
        })
}
</code></pre></pre>
<p>Now let's fuzz our <code>fibonacci</code> function:</p>
<pre><code class="language-bash">$ cargo bolero test fibonacci_test
    Finished test [unoptimized + debuginfo] target(s) in 0.10s
     Running target/fuzz/build_62a8ab526939db81/x86_64-apple-darwin/debug/deps/fibonacci_test-f9f8f1dcc806b6b6
...
thread 'main' panicked at 'attempt to add with overflow', my_fibonacci/tests/fibonacci_test/main.rs:8:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

======================== Test Failure ========================

Input:
93

Error:
panicked at 'attempt to add with overflow', my_fibonacci/tests/fibonacci_test/fuzz_target.rs:8:9

==============================================================
</code></pre>
<p>Uh oh... It looks like we've got a bug! <code>bolero</code> was able to find that calling our function with <code>93</code> results in an integer overflow. It's try fixing that by adding overflow checks with <a href="https://doc.rust-lang.org/std/primitive.u64.html#method.checked_add"><code>u64::checked_add</code></a>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// src/lib.rs

pub fn fibonacci(number: u64) -&gt; Option&lt;u64&gt; {
    let mut a = 0u64;
    let mut b = 1u64;

    for _ in 0..number {
        b = b.checked_add(core::mem::replace(&amp;mut a, b))?;
    }

    Some(b)
}
<span class="boring">}
</span></code></pre></pre>
<p>After running the <code>test</code> command for a few minutes things are looking better:</p>
<pre><code class="language-bash">$ cargo bolero test fibonacci_test
    Finished test [unoptimized + debuginfo] target(s) in 0.10s
     Running target/fuzz/build_62a8ab526939db81/x86_64-apple-darwin/debug/deps/fibonacci_test-f9f8f1dcc806b6b6
...
#272    INITED cov: 469 ft: 872 corp: 17/106b lim: 4 exec/s: 0 rss: 27Mb
    NEW_FUNC[1/1]: 0x102ef95f1
#277    NEW    cov: 476 ft: 880 corp: 18/112b lim: 6 exec/s: 0 rss: 27Mb L: 6/13 MS: 5 ChangeByte-ChangeBit-CopyPart-CopyPart-CrossOver-
#293    REDUCE cov: 476 ft: 880 corp: 18/109b lim: 6 exec/s: 0 rss: 27Mb L: 3/13 MS: 1 EraseBytes-
#341    NEW    cov: 476 ft: 928 corp: 19/119b lim: 6 exec/s: 0 rss: 27Mb L: 10/13 MS: 3 CMP-CopyPart-ChangeBinInt- DE: &quot; \x00\x00\x00\x00\x00\x00\x00&quot;-
#369    REDUCE cov: 476 ft: 928 corp: 19/118b lim: 6 exec/s: 0 rss: 27Mb L: 2/13 MS: 3 ShuffleBytes-ShuffleBytes-EraseBytes-
#397    REDUCE cov: 476 ft: 928 corp: 19/117b lim: 6 exec/s: 0 rss: 27Mb L: 1/13 MS: 3 ShuffleBytes-ChangeByte-EraseBytes-
#409    NEW    cov: 476 ft: 984 corp: 20/130b lim: 6 exec/s: 0 rss: 27Mb L: 13/13 MS: 2 ChangeByte-ChangeBinInt-
#501    NEW    cov: 476 ft: 1033 corp: 21/143b lim: 6 exec/s: 0 rss: 27Mb L: 13/13 MS: 2 ChangeBit-ChangeBinInt-
#977    REDUCE cov: 476 ft: 1033 corp: 21/139b lim: 8 exec/s: 0 rss: 27Mb L: 9/13 MS: 1 EraseBytes-
#1289   REDUCE cov: 476 ft: 1033 corp: 21/136b lim: 11 exec/s: 0 rss: 27Mb L: 10/13 MS: 2 ChangeASCIIInt-EraseBytes-
#1670   REDUCE cov: 476 ft: 1033 corp: 21/132b lim: 14 exec/s: 0 rss: 27Mb L: 9/10 MS: 1 EraseBytes-
#1741   REDUCE cov: 476 ft: 1033 corp: 21/131b lim: 14 exec/s: 0 rss: 27Mb L: 9/10 MS: 1 EraseBytes-
#10199  REDUCE cov: 476 ft: 1033 corp: 21/127b lim: 92 exec/s: 5099 rss: 27Mb L: 5/10 MS: 2 ChangeByte-EraseBytes-
#10455  REDUCE cov: 476 ft: 1033 corp: 21/125b lim: 92 exec/s: 5227 rss: 27Mb L: 3/10 MS: 1 EraseBytes-
#11753  REDUCE cov: 476 ft: 1033 corp: 21/121b lim: 104 exec/s: 5876 rss: 27Mb L: 5/10 MS: 3 ChangeBinInt-InsertByte-EraseBytes-
</code></pre>
<p>Are we done? Not quite... This is a good time to point out that basic fuzz testing can only get you so far. If we look on <a href="https://en.wikipedia.org/wiki/Fibonacci_number#Sequence_properties">Wikipedia</a> we find the following table:</p>
<table><thead><tr><th align="center">F0</th><th align="center">F1</th><th align="center">F2</th><th align="center">F3</th><th align="center">F4</th><th align="center">F5</th><th align="center">F6</th><th align="center">F7</th><th align="center">F8</th><th align="center">F9</th><th align="center">F10</th></tr></thead><tbody>
<tr><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">5</td><td align="center">8</td><td align="center">13</td><td align="center">21</td><td align="center">34</td><td align="center">55</td></tr>
</tbody></table>
<p>Do we actually know if the return value is correct? All we've really made sure of is that the implementation doesn't panic. It could be returning <code>42</code> for every answer and our fuzz tests wouldn't have caught it. How do we fix this?</p>
<h2><a class="header" href="#test-oracle" id="test-oracle">Test Oracle</a></h2>
<p>Using <a href="https://en.wikipedia.org/wiki/Test_oracle">test oracles</a> in conjection with our test can be an effective way to assert our implementation is correct. What is a test oracle? From <a href="https://blog.regehr.org/archives/1687">Write Fuzzable Code</a>:</p>
<blockquote>
<p>A test oracle decides whether a test case triggered a bug or not. By default, the only oracle available to a fuzzer like afl is provided by the OS’s page protection mechanism. In other words, it detects only crashes. We can do much better than this.</p>
<p>Assertions and their compiler-inserted friends — sanitizer checks — are another excellent kind of oracle. You should fuzz using as many of these checks as possible. Beyond these easy oracles, many more possibilities exist, such as:</p>
<ul>
<li>function-inverse pairs: does a parse-print loop, compress-decompress loop, encrypt-decrypt loop, or similar, work as expected?</li>
<li>differential: do two different implementations, or modes of the same implementation, show the same behavior?</li>
<li>metamorphic: does the system show the same behavior when a test case is modified in a semantics-preserving way, such as adding a layer of parentheses to an expression?</li>
<li>resource: does the system consume a reasonable amount of time, memory, etc. when processing an input?</li>
<li>domain specific: for example, is a lossily-compressed image sufficiently visually similar to its uncompressed version?</li>
</ul>
</blockquote>
<p>We've already seen a good example of a test oracle in action. Rust includes debug assertions for unchecked integer overflows. We were able to use these assertions in finding the limits of our implementation.</p>
<p>Unit tests could also be considered as test oracles and can be effective at asserting expected behavior of well known inputs and outputs.</p>
<h3><a class="header" href="#unit-tests" id="unit-tests">Unit tests</a></h3>
<p>The easiest solution is to copy the table values from wikipedia and test our function with a unit test:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// src/lib.rs

#[test]
fn fibonacci_test() {
    assert_eq!(fibonacci(0), Some(0));
    assert_eq!(fibonacci(1), Some(1));
    assert_eq!(fibonacci(2), Some(1));
    assert_eq!(fibonacci(3), Some(2));
    assert_eq!(fibonacci(4), Some(3));
    assert_eq!(fibonacci(5), Some(5));
    assert_eq!(fibonacci(6), Some(8));
    assert_eq!(fibonacci(7), Some(13));
    assert_eq!(fibonacci(8), Some(21));
    assert_eq!(fibonacci(9), Some(34));
    assert_eq!(fibonacci(10), Some(55));
}
<span class="boring">}
</span></code></pre></pre>
<p>Let's try running our unit test:</p>
<pre><code class="language-bash">$ cargo test
    Finished test [unoptimized + debuginfo] target(s) in 52.06s
     Running target/debug/deps/my_fibonacci-e9bfbebb80b3a5bf

running 1 test
test fibonacci_test ... FAILED

failures:

---- fibonacci_test stdout ----
thread 'fibonacci_test' panicked at 'assertion failed: `(left == right)`
  left: `Some(1)`,
 right: `Some(0)`', my_fibonacci/src/lib.rs:29:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    fibonacci_test

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>We haven't handled our zero case! Let's fix that:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// src/lib.rs

pub fn fibonacci(number: u64) -&gt; Option&lt;u64&gt; {
    if number == 0 {
        return Some(0);
    }

    let mut a = 0u64;
    let mut b = 1u64;

    for _ in 0..number {
        b = b.checked_add(core::mem::replace(&amp;mut a, b))?;
    }

    Some(b)
}
<span class="boring">}
</span></code></pre></pre>
<p>Let's run the test again:</p>
<pre><code class="language-bash">$ cargo test
    Finished test [unoptimized + debuginfo] target(s) in 52.06s
     Running target/debug/deps/my_fibonacci-e9bfbebb80b3a5bf

running 1 test
test fibonacci_test ... FAILED

failures:

---- fibonacci_test stdout ----
thread 'fibonacci_test' panicked at 'assertion failed: `(left == right)`
  left: `Some(2)`,
 right: `Some(1)`', my_fibonacci/src/lib.rs:35:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    fibonacci_test

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Another bug!? In this case we're actually looping 1 too many times. Here's the fix:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// src/lib.rs

pub fn fibonacci(number: u64) -&gt; Option&lt;u64&gt; {
    if number == 0 {
        return Some(0);
    }

    let mut a = 0u64;
    let mut b = 1u64;

    for _ in 1..number {
        b = b.checked_add(core::mem::replace(&amp;mut a, b))?;
    }

    Some(b)
}
<span class="boring">}
</span></code></pre></pre>
<p>After that final fix all of our tests pass:</p>
<pre><code class="language-bash">$ cargo test
    Finished test [unoptimized + debuginfo] target(s) in 52.06s
     Running target/debug/deps/my_fibonacci-e9bfbebb80b3a5bf

running 1 test
test fibonacci_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/fibonacci_test-e98d85aab754d963

running 1022 tests
...............................................................................
...............................................................................
...............................................................................
...............................................................................
...............................................................................
...............................................................................
...............................................................................
...............................................................................
...............................................................................
...............................................................................
...............................................................................
...............................................................................
..........................................................................
test result: ok. 1022 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h3><a class="header" href="#differential-oracle" id="differential-oracle">Differential Oracle</a></h3>
<p>We could also try to use the less-efficient, recursive method to check our implementation. It's easy to understand and implement:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn fibonacci_reccursive(n: u64) -&gt; Option&lt;u64&gt; {
    match n {
        0 =&gt; Some(0),
        1 =&gt; Some(1),
        _ =&gt; fibonacci_reccursive(n - 1)?.checked_add(fibonacci_reccursive(n - 2)?),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The problem with that approach is it ends up being <em>way</em> too slow for larger numbers, even in <code>--release</code> mode.</p>
<p>Another option is to use a 3rd party implementation. Doing a quick search on <a href="https://crates.io/">crates.io</a> results in a <a href="https://crates.io/crates/fibonacci">crate that implements the fibonacci sequence</a>. There's also a problem with that: the crate actually has the same bug as our implementation. It skips the first two values in the sequence <code>0</code> and <code>1</code>.</p>
<h3><a class="header" href="#conclusion" id="conclusion">Conclusion</a></h3>
<p>The takeaway is some thought needs to go into how to test your implementation effectively. Often times, combining multiple approaches will provide the best result.</p>
<h1><a class="header" href="#developer-documentation" id="developer-documentation">Developer documentation</a></h1>
<p><code>bolero</code> is an open source project that welcomes external contributions.
One of the easiest ways to contribute is to <a href="https://github.com/camshaft/bolero/issues/new">report any issue</a>
you encounter while using the tool.</p>
<p>If you want to contribute to its development, this chapter provides
documentation that might be helpful for developers.</p>
<h1><a class="header" href="#build-from-source" id="build-from-source">Build from source</a></h1>
<p>In general, the following dependencies are required to build <code>bolero</code> from source.</p>
<h2><a class="header" href="#dependencies" id="dependencies">Dependencies</a></h2>
<ul>
<li>The Rust toolchain (<code>cargo</code>, <code>rustfmt</code>, etc.) installed via <a href="https://rustup.rs/">rustup</a></li>
<li><code>make</code></li>
</ul>
<p><code>bolero</code> has been tested in <a href="dev-docs/build.html#ubuntu-2204"><code>Ubuntu 22.04</code></a> and <a href="dev-docs/build.html#macos-12"><code>macOS 12</code></a> platforms.</p>
<h3><a class="header" href="#ubuntu-2204" id="ubuntu-2204">Ubuntu 22.04</a></h3>
<pre><code class="language-bash">sudo apt update
sudo apt install binutils-dev libunwind-dev
</code></pre>
<p><code>make</code> comes pre-installed on Ubuntu, but if for some reason it isn't,
it can be installed using the command:</p>
<pre><code class="language-bash">sudo apt install make
</code></pre>
<h3><a class="header" href="#macos-12" id="macos-12">macOS 12</a></h3>
<p><code>make</code> can be installed using the command:</p>
<pre><code class="language-bash">xcode-select --install
</code></pre>
<p>No other dependencies are required.</p>
<h2><a class="header" href="#build-and-test" id="build-and-test">Build and test</a></h2>
<p>The <a href="https://github.com/camshaft/bolero/blob/master/Makefile"><code>Makefile</code></a> located in the
root directory can be used to build <code>bolero</code> and run it on several test suites. To execute
it, just run:</p>
<pre><code class="language-bash">make
</code></pre>
<p>This should compile <code>bolero</code> and run multiple tests. In the process, it's
possible that you are shown the following message:</p>
<pre><code>[-] Hmm, your system is configured to send core dump notifications to an
    external utility. This will cause issues: there will be an extended delay
    between stumbling upon a crash and having this information relayed to the
    fuzzer via the standard waitpid() API.

    To avoid having crashes misinterpreted as timeouts, please log in as root
    and temporarily modify /proc/sys/kernel/core_pattern, like so:

    echo core &gt;/proc/sys/kernel/core_pattern
</code></pre>
<p>This message comes from AFL. You can either modify the file as indicated or
re-run the <code>make</code> command as follows:</p>
<pre><code class="language-bash">AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES=1 make
</code></pre>
<p>However, this doesn't guarantee that the AFL tests will pass. In that case, the
best option is to temporarily modify the <code>/proc/sys/kernel/core_pattern</code> file.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
